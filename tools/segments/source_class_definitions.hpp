
// Copyright 2007 Edd Dawson.
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

"",
"file_not_found::file_not_found(const std::string &filename) :",
"    std::runtime_error(\"no such embedded file: \" + filename)",
"{",
"}",
"",
"file_not_found::~file_not_found() throw()",
"{",
"}",
"",
"struct file::impl",
"{",
"    // This stream buffer acts as the broker for the embedded data when accessed through a file's",
"    // istream().",
"    class embd_buf : public std::streambuf",
"    {",
"        public:",
"            static const std::size_t put_back = 10;",
"            static const std::size_t buffer_size = 256;",
"",
"            embd_buf(const char *begin, const char *end) :",
"                begin_(begin),",
"                end_(end)",
"            {",
"                reset();",
"            }",
"",
"            void reset()",
"            {",
"                src_ = begin_;",
"                char *p = buff_ + sizeof buff_;",
"                setg(p, p, p);",
"            }",
"",
"            const char *src_begin() const { return begin_; }",
"",
"            const char *src_end() const { return end_; }",
"",
"            int_type underflow()",
"            {",
"                if (gptr() < egptr()) // buffer not exhausted",
"                    return traits_type::to_int_type(*gptr());",
"",
"                char *p = buff_;",
"",
"                if (eback() == buff_) // true when this isn't the first fill",
"                {",
"                    // Make arrangements for putback characters",
"                    std::memmove(buff_, egptr() - put_back, put_back);",
"                    p += put_back;",
"                }",
"",
"                // p is now the p of the buffer, proper.",
"                // Read from the source data in to the provided buffer",
"                std::size_t n = 0;",
"                while (src_ != end_ && p != (buff_ + sizeof buff_))",
"                {",
"                    *p++ = *src_++;",
"                    ++n;",
"                }",
"                if (n == 0) return traits_type::eof();",
"",
"                setg(buff_, p - n, p);",
"",
"                return traits_type::to_int_type(*gptr());",
"            }",
"",
"        private:",
"            const char * const begin_;",
"            const char * const end_;",
"            const char *src_;",
"            char buff_[put_back + buffer_size];",
"    };",
"",
"    impl(const char *filename, const char *data_begin, const char *data_end) :",
"        filename(filename),",
"        buffer(data_begin, data_end),",
"        stream(&buffer)",
"    {",
"    }",
"",
"    impl(const impl &other) :",
"        filename(other.filename),",
"        buffer(other.buffer.src_begin(), other.buffer.src_end()),",
"        stream(&buffer)",
"    {",
"    }",
"",
"    const char *filename;",
"    embd_buf buffer;",
"    std::istream stream;",
"};",
"",
"file::file(const std::string &filename)",
"{",
"    const index_entry *b = files_index;",
"    const index_entry *e = files_index + sizeof files_index / sizeof *files_index;",
"",
"    for( ; b != e; ++b)",
"    {",
"        if (filename == b->filename)",
"        {",
"            pimpl_ = new impl(b->filename, b->data_begin, b->data_end);",
"            return;",
"        }",
"    }",
"",
"    throw file_not_found(filename);",
"}",
"",
"",
"file::file(const file &other) :",
"    pimpl_(new impl(*other.pimpl_))",
"{",
"}",
"",
"file &file::operator= (const file &other)",
"{",
"    file temp(other);",
"    swap(temp);",
"    return *this;",
"}",
"",
"file::~file() { delete pimpl_; }",
"",
"void file::swap(file &other) { std::swap(pimpl_, other.pimpl_); }",
"",
"const char *file::name() const { return pimpl_->filename; }",
"",
"std::istream &file::istream() { return pimpl_->stream; }",
"",
"void file::reset_stream() { pimpl_->buffer.reset(); pimpl_->stream.clear(); }",
"",
"file::const_iterator file::begin() const { return pimpl_->buffer.src_begin(); }",
"",
"file::const_iterator file::end() const { return pimpl_->buffer.src_end(); }",
"",
"",
"",
"file_name_iterator &file_name_iterator::operator++ ()",
"{",
"    assert(*this != end());",
"    p_ = static_cast<const index_entry *>(p_) + 1;",
"    return *this;",
"}",
"",
"file_name_iterator file_name_iterator::operator++ (int)",
"{",
"    file_name_iterator temp(p_);",
"    ++*this;",
"    return temp;",
"}",
"",
"file_name_iterator &file_name_iterator::operator-- ()",
"{",
"    assert(*this != begin());",
"    p_ = static_cast<const index_entry *>(p_) - 1;",
"    return *this;",
"}",
"",
"file_name_iterator file_name_iterator::operator-- (int)",
"{",
"    file_name_iterator temp(p_);",
"    --*this;",
"    return temp;",
"}",
"",
"file_name_iterator::reference file_name_iterator::operator* () const",
"{",
"    assert(*this != end());",
"    const index_entry * ie = static_cast<const index_entry *>(p_);",
"    return ie->filename;",
"}",
"",
"file_name_iterator::pointer file_name_iterator::operator-> () const",
"{",
"    assert(*this != end());",
"    return &(static_cast<const index_entry * const>(p_)->filename);",
"}",
"",
"bool file_name_iterator::operator== (const file_name_iterator &rhs) const",
"{",
"    return p_ == rhs.p_;",
"}",
"",
"bool file_name_iterator::operator!= (const file_name_iterator &rhs) const",
"{",
"    return p_ != rhs.p_;",
"}",
"",
"file_name_iterator file_name_iterator::begin()",
"{",
"    return file_name_iterator(files_index);",
"}",
"",
"file_name_iterator file_name_iterator::end()",
"{",
"    return file_name_iterator(files_index + sizeof files_index / sizeof *files_index);",
"}",
"",
"file_name_iterator::file_name_iterator(const void *p) :",
"    p_(p)",
"{",
"}",
"",
""
